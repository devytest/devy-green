class Pokemon {

  /*
    Pokemon Attributes:
    - owner
    - element
    - HP
    - baseHP
    - maxHP
    - AP
    - baseAP
    - XP
    - level
    - attacks
    - formNUmber
    - forms 
      - species
      - element
      - baseHP
      - baseAP
      - attacks
  */
  constructor(options) {

    // input params
    this.owner = options.owner
    this.element = options.element
    this.forms = options.forms
    this.XP = options.XP

    this.updateLevel()
  }

  /*
    bark() returns a string representing a pokemon's 'bark.'
    Each pokemon 'barks' the name of its species.
    For example, every Pikachu barks 'Pikachu!'
  */
  bark() {
    return `<p>${this.species}!</p>`
  }

  /*
    refillHP() sets the pokemon's HP to its maximum value
  */
  refillHP() {
    this.HP = this.maxHP
  }

  /*
    updateMaxHP() calculates and updates the pokemon's
    maxHP. It does this by setting the pokemon's maxHP
    to its baseHP multiplied by its level.
  */
  updateMaxHP() {
    this.maxHP = this.baseHP * this.level
  }

  /*
    updateAP() calculates and updates the pokemon's
    AP. It does this by setting the pokemon's AP
    to its baseAP multiplied by its level.
  */
  updateAP() {
    this.AP = this.baseAP * this.level
  }

  /*
    updateXP() calculates the amount of XP the pokemon
    has earned after defeating 'enemies'. It then adds
    earnedXP to its current XP 
  */
  updateXP(enemies) {
    var earnedXP = this.calcEarnedXP(enemies)
    this.addXP(earnedXP)
  }
  

  /*
    calculateEarnedXP(...) is given an array of 'enemies' and it returns the total amount of XP earned by defeating all of
    them. To do this, it loops through all enemies, calling each enemy's giveUpXP() method. Each time it calls giveUpXP(), it adds the value to a running sum. This determines the total amount of XP our pokemon has earned by defeating all of the enemies. It returns this amount.
  */
  calcEarnedXP(enemies) {
    var earnedXP = 0
    for (var i = 0; i < enemies.length; i++) {
      earnedXP += enemies[i].giveUpXP()
    }
    return earnedXP
  }

  /*
    addXP(...) increases the pokemon's XP by 'newXP' points
  */
  addXP(newXP) {
    this.XP += newXP
  }
  
  /*
    giveUpXP() returns the amount of XP this pokemon gives up
    when it is killed by an opponent.

    This amount should equal:
      - the pokemon's current XP divided by 4
      - rounded to the nearest whole number (integer).
  */
  giveUpXP() {
    return Math.round(this.XP / 4.0)
  }

  /*
    updateLevel() calculates and updates the pokemon's level.
    A pokemon's level is determined by:
      - dividing its XP by 100
      - rounding this value down

    For example:
      a pokemon with XP = 140 should be level 1
      a pokemon with XP = 670 should be level 6
      a pokemon with XP = 899 should be level 8

    Note: Pokemon start with XP = 100
  */
  updateLevel() {
    this.level = Math.floor(this.XP/100.0)
  }

  /*
    levelUp() is used when the pokemon has gained enough XP
    to cross over to the next level. When this happens,
    the following should happen:
      - the pokemon's maximum HP should be updated
      - the pokemon's AP should be updated
      - the pokemon's HP should be refilled
      - we should check if the pokemon should evolve
  */
  levelUp() {
    this.updateMaxHP()
    this.updateAP()
    this.refillHP()
    this.evolveIfNecessary()
  }

  updateStats(enemies) {
    this.updateXP(enemies)
    var oldLevel = this.level
    this.updateLevel()
    if (this.level > oldLevel) {
      this.levelUp()
    }
  }

  /*
    returns true if pokemon evolved
  */
  evolveIfNecessary() {
    var evolved = false
    
    if (this.level <= 3) {
      if (this.formNumber != 1) {
        this.evolveToForm(1)
        evolved = false
      }
    } else if (this.level > 3 && this.level < 7) {
      if (this.formNumber != 2) {
        this.evolveToForm(2)
        evolved = true
      }
    } else if (this.level >= 7) {
      if (this.formNumber != 3) {
        this.evolveToForm(3)
        evolved = true
      }
    }

    return evolved
  }

  /*

  */
  evolveToForm(formNumber) {
    var newForm = self.forms[formNumber]

    this.formNumber = formNumber
    self.species = newForm.species
    self.element = newForm.element
    self.baseHP = newForm.baseHP
    self.AP = newForm.AP
    self.attacks = newForm.attacks
  }

  
  /*
    calcDamage(...) calculates and returns the amount of 
    damage generated by this pokemon using 'attack'
    against 'target.'

    Damage is calculated by:
      - First multiplying:
        - the pokemon's AP
        - times the attack's power
        - times the element multiplier 
      - And then rounding the result
    
    Note: the element multiplier is calculated by the
    calcElementMultiplier(...) method
  */
  calcDamage(attack, target) {
    var EM = this.calcElementMultiplier(this, target)
    var damage = this.AP * attack.power * EM
    return Math.round(damage)
  }

  /*
    checkIfAttackHit(...) returns a boolean value (true or false) 
    indicating whether the attack hit its target or not.
    Returns true if the attack hit and false if it missed.
  */
  checkIfAttackHit(attack) {
    var rand = Math.random()
    if (rand < attack.accuracy) {
      return true
    } else {
      return false
    }
  }

  /*
    receieveDamage(...) updates the pokemon's HP by
    subtracting 'damage' from its current HP. It also
    ensures that the pokemon's HP is never less than 0.
  */
  receiveDamage(damage) {
    this.HP -= damage
    
    // ensure that HP is never negative
    if (this.HP < 0) {
      this.HP = 0
    }
  }

  /* 
  calcElementMultiplier(...) calculates and returns the damage multiplier based on attacker's element and target's element.
  
  Element Relationships:
  'fire'  overpowers 'plant'
  'plant' overpowers 'water'
  'water' overpowers 'fire'
  
  If the attacker's element overpowers the target's element,
  then we return a multipler of 1.5 ('EXTRA_DAMAGE').

  If the attacker's element is overpowered by the target's element,
  then we return a multipler of 0.67 ('REDUCED_DAMAGE').

  If the attacker and targer have the same element, 
  we return a multiplier of 1.0 (NORMAL_DAMAGE).

  For example:
    If the attacker is 'water' and the target is 'fire',
    the multiplier will be 1.5 (3/2)
    because 'water' overpowers 'fire', 

    But if the attacker is 'fire' and the target is 'water',
    the multiplier will be 0.67 (2/3)
    because 'fire' is overpowered by 'water.' 
  */
  calcElementMultiplier(attacker, target) {
    var EXTRA_DAMAGE   = 1.5
    var NORMAL_DAMAGE  = 1.0
    var REDUCED_DAMAGE = 0.67

    var attackerElement = attacker.element
    var targetElement = target.element

    if (attackerElement === "fire") {
      if (targetElement === "water") {
        return REDUCED_DAMAGE
      } else if (targetElement === "plant") {
        return EXTRA_DAMAGE
      } else {
        return NORMAL_DAMAGE
      }
    } else if (attackerElement === "water") {
      if (targetElement === "plant") {
        return REDUCED_DAMAGE
      } else if (targetElement === "fire") {
        return EXTRA_DAMAGE
      } else {
        return NORMAL_DAMAGE
      }
    } else if (attackerElement === "plant") {
      if (targetElement === "fire") {
        return REDUCED_DAMAGE
      } else if (targetElement === "water") {
        return EXTRA_DAMAGE
      } else {
        return NORMAL_DAMAGE
      }
    }
  }
  
  /*
    Used by enemy AI to choose one of its attacks

    Currently chooses randomly

    Alternatives:
    select strongest attack
    select weakest attack
    select most accurate attack
    round robin through attacks
    etc.
  */
  selectAttack() {
    return this.selectRandomAttack()
  }

  /*
    Alternative strategy for selectAttack()
  */
  selectRandomAttack() {
    var attacks = this.getArrayOfAttacks()
    var attackIndex = Math.floor(
      Math.random() * attacks.length
    )

    return attacks[attackIndex]
  }

  /*
    selectMostPowerfulAttack() selects the attack with the highest
    power level. It is an alternative strategy for selectAttack().
  */
  selectMostPowerfulAttack() {
    var attacks = this.getArrayOfAttacks()
    
    // will store the index of the strongest attack
    var strongestIndex = 0

    for (var i=0; i < attacks.length; i++) {
      if (attacks[i].power > attacks[strongestIndex].power) {
        strongestIndex = i
      }
    }

    return attacks[strongestIndex] 
  }

  /*
    Alternative strategy for selectAttack()
  */
  selectLeastPowerfulAttack() {
    var attacks = this.getArrayOfAttacks()
    
    // will store the index of the weakest attack
    var weakestIndex = 0

    for (var i=0; i < attacks.length; i++) {
      if (attacks[i].power < attacks[weakestIndex].power) {
        weakestIndex = i
      }
    }

    return attacks[weakestIndex] 
  }

  /*
    Alternative strategy for selectAttack()
  */
  selectMostAccurateAttack() {
    var attacks = this.getArrayOfAttacks()
    
    // will store the index of the most accurate attack
    var mostAcc = 0 

    for (var i=0; i < attacks.length; i++) {
      if (attacks[i].accuracy > attacks[mostAcc].accuracy) {
        mostAcc = i
      }
    }

    return attacks[mostAcc] 
  }

  getArrayOfAttacks() {
    return Object.keys(this.attacks).map(key => this.attacks[key])
  }
}